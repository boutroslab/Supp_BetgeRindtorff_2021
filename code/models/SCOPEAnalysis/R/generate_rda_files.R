
#' @title Generate RDA files for Organoid Viability
#'
#' @description Transforms the data generated by the Python code into RDA
#'     files used by the organoid viability vignette. This function is not
#'     meant to be run and serves only as a 'log' for the conversion steps.
#'
#'     The function assumes the current working directory is the base
#'     directory of the package, i.e. where the folders 'data', 'R', etc.
#'     are located.
#'
#' @usage generate_rda_files_viability()
#'
#' @return A boolean indicating that the function ran without error.
#'
#' @author Jan Sauer
#'
#' @examples print(generate_rda_files_viability)
generate_rda_files_viability = function() {
  library(PharmacoGx)
  library(tidyverse)

  ## Organoid Viability
  viability_directory = paste0(
    "/Users/jansauer/Thesis/Projects/PROMISE/",
    "FeatureAnalysis/organoid_viability")

  # Load mortality data for classifier trained on all channels
  mortality = load_classification_results(directory = viability_directory)
  mortality$Replicate = get_replicate_ids_for_plates(mortality$Plate.ID)
  mortality$Layout = substr(mortality$Plate.ID, 12, 14)

  # Load mortality data of reduced classifiers
  mortality_reduced = list()
  for(ch in c("Actin", "FITC", "DAPI", "Actin_DAPI")) {
    mortality_channel = load_classification_results(
      directory = viability_directory, channels = ch)
    mortality_channel = mortality_channel[rownames(mortality), ]
    mortality_channel$Replicate = get_replicate_ids_for_plates(
      mortality_channel$Plate.ID)
    mortality_channel$Layout = substr(mortality_channel$Plate.ID, 12, 14)
    mortality_reduced[[ch]] = mortality_channel
  }

  # Load pathway/target annotations for all drugs
  layout_fn = "data/Layouts.csv"
  all_drugs = sort(unique(mortality$Product.Name))
  drug_annotations = data.frame(
    "Drug" = all_drugs,
    "Pathways" = get_mode_of_action_from_file(layout_fn = layout_fn, drugs = all_drugs),
    "Targets" = get_targets_from_file(layout_fn = layout_fn, drugs = all_drugs),
    row.names = all_drugs,
    stringsAsFactors = FALSE)

  # Load ROC data both for native and transfer accuracies
  roc_data = list()
  roc_aucs = list()
  for(line1 in get_lines()) {
    for(line2 in get_lines()) {
      dat = load_roc_data(
        directory = viability_directory, clf_line = line1, data_line = line2)
      roc = dat$df
      roc$clf_line = line1
      roc$data_line = line2
      roc_data[[length(roc_data)+1]] = roc

      roc_aucs[[length(roc_aucs)+1]] = data.frame(
        "clf_line" = line1,
        "data_line" = line2,
        "AUC" = dat$auc)
    }
  }
  roc_data = do.call(rbind, roc_data)
  rownames(roc_data) = NULL
  roc_aucs = do.call(rbind, roc_aucs)

  # Calculate dose-response AUC curves of drugs with concentrations
  # for the classifiers trained on all channels
  auc_img_full <- mortality %>%
    filter(!is.na(mortality$Concentration)) %>%
    group_by(Plate.ID, Product.Name) %>%
    arrange(Concentration) %>%
    mutate(
      s_AUC_fit = 1 - computeAUC(
        Concentration, Percent.Live, verbose=T,
        viability_as_pct = F, area.type = 'Fitted'),
      s_AUC_actual = 1 - computeAUC(
        Concentration, Percent.Live, verbose=T,
        viability_as_pct = F, area.type='Actual')) %>%
    group_by(Line, Product.Name) %>%
    arrange(Concentration) %>%
    mutate(
      l_AUC_fit = 1 - computeAUC(
        Concentration, Percent.Live, verbose=F,
        viability_as_pct = F, area.type = 'Fitted'),
      l_AUC_actual = 1 - computeAUC(
        Concentration, Percent.Live, verbose=F,
        viability_as_pct = F, area.type='Actual')) %>%
    ungroup() %>% as.data.frame()

  # Calculate dose-response AUC curves of drugs with concentrations
  # for the classifiers trained on the Actin and Nucleus Channels
  # (red and blue)
  auc_img_twoChannel <- mortality_reduced$Actin_DAPI %>%
    filter(!is.na(mortality_reduced$Actin_DAPI$Concentration)) %>%
    group_by(Plate.ID, Product.Name) %>%
    arrange(Concentration) %>%
    mutate(
      s_AUC_fit = 1 - computeAUC(
        Concentration, Percent.Live, verbose=T,
        viability_as_pct = F, area.type = 'Fitted'),
      s_AUC_actual = 1 - computeAUC(
        Concentration, Percent.Live, verbose=T,
        viability_as_pct = F, area.type='Actual')) %>%
    group_by(Line, Product.Name) %>%
    arrange(Concentration) %>%
    mutate(
      l_AUC_fit = 1 - computeAUC(
        Concentration, Percent.Live, verbose=F,
        viability_as_pct = F, area.type = 'Fitted'),
      l_AUC_actual = 1 - computeAUC(
        Concentration, Percent.Live, verbose=F,
        viability_as_pct = F, area.type='Actual')) %>%
    ungroup() %>% as.data.frame()

  # Calculate dose-response AUC curves of drugs with concentrations
  # for the Cell-Titer-Glo (CTG) data.
  ctg_input_data = as.data.frame(readRDS("data/ctg.rds"))
  auc_ctg <- ctg_input_data %>%
    group_by(screen, drug) %>%
    arrange(Concentration) %>%
    mutate(
      s_AUC_fit = 1 - computeAUC(
        Concentration, viability, verbose=F,
        viability_as_pct = F, area.type = 'Fitted'),
      s_AUC_actual = 1 - computeAUC(
        Concentration, viability, verbose=F,
        viability_as_pct = F, area.type='Actual')) %>%
    group_by(Line, drug) %>%
    arrange(Concentration) %>%
    mutate(
      l_AUC_fit = 1 - computeAUC(
        Concentration, viability, verbose=F,
        viability_as_pct = F, area.type = 'Fitted'),
      l_AUC_actual = 1 - computeAUC(
        Concentration, viability, verbose=F,
        viability_as_pct = F, area.type='Actual')) %>%
    ungroup() %>% as.data.frame()

  # Load Accuracy Matrices
  acc_matrix = load_transfer_matrix(directory = viability_directory)
  acc_matrix_reduced = list()
  for(ch in c("Actin", "FITC", "DAPI", "Actin_DAPI")) {
    acc_matrix_reduced[[ch]] = load_transfer_matrix(
      directory = viability_directory, channels = ch)
  }

  # Save into RData file
  save(mortality, mortality_reduced, drug_annotations, roc_data, roc_aucs,
       auc_img_full, auc_img_twoChannel, auc_ctg, acc_matrix,
       acc_matrix_reduced, file = "data/organoid_viability.RData")

  return(TRUE)
}

#' @title Generate RDA files for Drug Effects
#'
#' @description Transforms the data generated by the Python code into RDA
#'     files used by the drug effects vignette. This function is not
#'     meant to be run and serves only as a 'log' for the conversion steps.
#'
#'     The function assumes the current working directory is the base
#'     directory of the package, i.e. where the folders 'data', 'R', etc.
#'     are located.
#'
#' @usage generate_rda_files_drugeffects()
#'
#' @return A boolean indicating that the function ran without error.
#'
#' @author Jan Sauer
#'
#' @examples print(generate_rda_files_drugeffects)
generate_rda_files_drugeffects = function() {

  drug_effect_directory = paste0(
    "/Users/jansauer/Thesis/Projects/PROMISE/",
    "FeatureAnalysis/drug_effects/human")

  n_components = 25

  drug_effect_metadata = list()
  drug_effect_profiles = list()
  for(line in get_lines()) {
    md_fn = file.path(
      drug_effect_directory, line,
      sprintf("SVM_Accuracies_PCA_%s_%scomponents.csv",
              line, n_components))
    drug_effect_metadata[[line]] = read.csv(md_fn, row.names = 1)
    drug_effect_metadata[[line]]$Line = line
    drug_effect_metadata[[line]]$Drug = rownames(drug_effect_metadata[[line]])
    profiles_fn = file.path(
      drug_effect_directory, line,
      sprintf("SVM_Profiles_mean_PCA_%s_%scomponents.csv",
              line, n_components))
    drug_effect_profiles[[line]] = read.csv(profiles_fn, row.names = 1)
  }

  drug_effect_metadata = do.call(rbind, drug_effect_metadata)
  drug_effect_profiles = do.call(rbind, drug_effect_profiles)

  # Reconstruct Concentration
  drug_effect_metadata$Concentration = NA
  drugsplit = strsplit(drug_effect_metadata$Drug, "__")
  drug_effect_metadata$Concentration[lengths(drugsplit) == 2] = as.numeric(sapply(
    strsplit(drug_effect_metadata$Drug[lengths(drugsplit) == 2], "__"),
    "[[", 2))
  drug_effect_metadata$Drug[lengths(drugsplit) == 2] = sapply(
    strsplit(drug_effect_metadata$Drug[lengths(drugsplit) == 2], "__"),
    "[[", 1)

  # DMSO jitter
  # Some functions dislike duplicates, i.e. all DMSO vectors are by definition
  # (0, ..., 0), so I include small, random variations in any distance of 0.
  # The range of +/- 1e-6 is far below any other changes so it doesn't
  # significantly alter the clustering.
  drug_effect_metadata$Distance[drug_effect_metadata$Distance == 0] = runif(
    n = sum(drug_effect_metadata$Distance == 0), min = -1e-6, max = 1e-6)

  # Rescale Profiles
  # The original length depends mostly on the SVM parameters and bears no
  # biological or data-specific significance.
  drug_effect_profiles = t(apply(
    drug_effect_profiles, 1, function(x) x / sqrt(sum(x**2))))
  dist_scale = matrix(
    rep(drug_effect_metadata$Distance, ncol(drug_effect_profiles)),
    ncol = ncol(drug_effect_profiles))
  drug_effect_profiles = drug_effect_profiles * dist_scale

  save(drug_effect_profiles, drug_effect_metadata,
       file = "data/drug_effects.RData")
}

#' @title Generate RDA file of Well Averaged Features
#'
#' @description Transforms the data generated by the Python code into RDA
#'     files used by the drug effects vignette. This function is not
#'     meant to be run and serves only as a 'log' for the conversion steps.
#'
#'     The function assumes the current working directory is the base
#'     directory of the package, i.e. where the folders 'data', 'R', etc.
#'     are located.
#'
#' @usage generate_rda_files_wellfeatures()
#'
#' @return A boolean indicating that the function ran without error.
#'
#' @author Jan Sauer
#'
#' @examples print(generate_rda_files_wellfeatures)
generate_rda_files_wellfeatures = function() {
  library(h5)

  featuresdir = paste0(
    "/local-collab-ag-fischer/PROMISE/data-10x-4t-c-16z/",
    "features/")

  # Load well features
  plates = SCOPEAnalysis::get_plates()
  well_features = list()
  well_metadata = list()
  for(plate in plates) {
    h5f = h5file(
      name = file.path(featuresdir, plate, sprintf(
        "%s_averaged_features.h5", plate)),
      mode = "r")
    well_features[[plate]] = data.frame(t(h5f["features_organoids"][]))
    colnames(well_features[[plate]]) = h5f["feature_names_organoids"][]
    rownames(well_features[[plate]]) = h5f["well_names_organoids"][]
    well_metadata[[plate]] = data.frame(
      h5f["metadata_organoids"][], stringsAsFactors = FALSE)
    colnames(well_metadata[[plate]]) = h5f["metadata_names_organoids"][]
    rownames(well_metadata[[plate]]) = h5f["well_names_organoids"][]
    h5close(h5f)
  }
  well_features = do.call(rbind, well_features)
  well_metadata = do.call(rbind, well_metadata)

  well_metadata$Concentration = as.numeric(well_metadata$Concentration)
  well_metadata$Replicate = as.numeric(well_metadata$Replicate)
  rownames(well_metadata) = substr(rownames(well_metadata), 16, 34)
  rownames(well_features) = substr(rownames(well_features), 16, 34)

  save(well_features, well_metadata, file = "data/well_features.RData")
}

load_classification_results = function(directory, channels=NULL) {
  mortality = list()
  lines = get_lines()
  for(line in lines) {
    if(is.null(channels)) {
      fn = file.path(directory, "results", sprintf(
        "%s_organoid_classification.csv", line))
    } else {
      fn = file.path(directory, "results", sprintf(
        "%s_organoid_classification__%s.csv", line, channels))
    }
    mortality[[line]] = read.csv(fn, stringsAsFactors = FALSE)
  }
  mortality = do.call(rbind, mortality)
  rownames(mortality) = paste0(
    mortality$Plate.ID, "_",
    substr(mortality$Well.ID, 1, 1), "_",
    substr(mortality$Well.ID, 2, 3))
  mortality$Line = substr(mortality$Plate.ID, 1, 7)

  # Keep only the wells with replicates
  rep_id = paste0(
    mortality$Line, "_", substr(mortality$Plate.ID, 12, 14),
    "_", mortality$Well.ID)
  wells_to_keep = names(which(table(rep_id) >= 2))
  mortality = mortality[rep_id %in% wells_to_keep, ]
  return(mortality)
}

load_roc_data = function(directory, clf_line, data_line, channels=NULL) {
  if(is.null(channels)) {
    fn = file.path(directory, "diagnostics", sprintf(
      "roc_data_%s_on_%s.csv", clf_line, data_line))
  } else {
    fn = file.path(directory, "diagnostics", sprintf(
      "roc_data_%s_on_%s__%s.csv", clf_line, data_line, channels))
  }
  roc = read.csv(fn, stringsAsFactors = FALSE, comment.char = "#")

  auc = readLines(fn)
  auc = auc[substr(auc, 1, 5) == "# AUC"]
  auc = as.numeric(strsplit(auc, ":")[[1]][2])
  return(list("df" = roc, "auc" = auc))
}

load_transfer_matrix = function(directory, channels=NULL) {
  if(is.null(channels)) {
    fn = file.path(directory, "diagnostics", "TransferLearningMatrix.csv")
  } else {
    fn = file.path(directory, "diagnostics", sprintf(
      "TransferLearningMatrix__%s.csv", channels))
  }
  mat = as.matrix(read.csv(
    fn, stringsAsFactors = FALSE, comment.char = "#", row.names = 1))
  return(mat)
}

get_mode_of_action_from_file = function(layout_fn, drugs) {
  layouts = read.csv2(layout_fn, stringsAsFactors = FALSE)
  layouts = layouts[, c("Product.Name", "Pathway")]
  layouts = unique(layouts)

  # Some entries might be duplicated. For those that are, remove any without pathway
  # information
  dup_drugs = names(which(table(layouts$Product.Name) == 2))
  remove_entries = which(
    is.na(layouts$Pathway) &
      layouts$Product.Name %in% dup_drugs)
  if(length(remove_entries) > 0) layouts = layouts[-remove_entries, ]
  rownames(layouts) = layouts$Product.Name
  return(layouts[drugs, "Pathway"])
}

get_targets_from_file = function(layout_fn, drugs) {
  layouts = read.csv2(layout_fn, stringsAsFactors = FALSE)
  layouts = layouts[, c("Product.Name", "Target")]
  layouts = unique(layouts)

  # Some entries might be duplicated. For those that are, remove any without pathway
  # information
  dup_drugs = names(which(table(layouts$Product.Name) == 2))
  remove_entries = which(
    is.na(layouts$Target) &
      layouts$Product.Name %in% dup_drugs)
  if(length(remove_entries) > 0) layouts = layouts[-remove_entries, ]

  # Merge the Targets of duplicated entries
  merged_layouts = list()
  for(prod in unique(layouts$Product.Name)) {
    if(sum(layouts$Product.Name == prod) == 1) {
      merged_layouts[[prod]] = as.character(layouts[layouts$Product.Name == prod, ])
    } else {
      full_targets = paste0(layouts[layouts$Product.Name == prod, "Target"], collapse = ", ")
      merged_layouts[[prod]] = c(prod, full_targets)
    }
  }
  merged_layouts = data.frame(do.call(rbind, merged_layouts), stringsAsFactors = FALSE)
  colnames(merged_layouts) = c("Product.Name", "Target")
  rownames(merged_layouts) = merged_layouts$Product.Name
  merged_layouts$Product.Name = NULL
  return(merged_layouts[drugs, "Target"])
}
