#' @title Check logfiles of jobs
#' 
#' @description This function checks whether jobs ran successfully. It checks 
#'   log files and verifies the hdf5dir and hdf5projection entry for all files 
#'   with non-empty log files. Note that it only checks the hdf5validation 
#'   file to confirm the file in hdf5dir, it does not actually compare TIF 
#'   imagtes with the h5 files. The function then creates shell scripts to fix 
#'   the bad files.
#' 
#' @param plateIndir The directory name of the plate as generated by the 
#'   microscope
#' @param platename The ID (and folder name) of the plate
#' @param outfile The location to write the fix-script to
#' @param configdir The configuration file, which defines the number of 
#'   z-stacks, channels, and fields
#' 
#' @return A list of lists indicating incorrect hdf5dir files and projections
#' 
#' @author Jan Sauer
#' 
#' @examples print(checkLogs)
#' @export
checkLogs <- function(plateIndir, platename, outfile, configdir) {
  source(file.path(configdir, "watchdogConfig.R"))
  
  # Check if there is a log folder for the plate in question
  logdir = file.path(configdir, "status", "log", platename)
  if(!dir.exists(logdir)) {
    warning(sprintf("Log directory doesn't exist for '%s'", platename))
    return(FALSE)
  }
  
  # Check that the plate is complete
  # This check might not be a good idea as the job could have cancelled before creating either of these directories 
  # if(length(list.files(file.path(hdf5dir, platename))) != nrWells) {
  #   warning(sprintf("Plate '%s' seems to be incomplete (hdf5dir incomplete)", platename))
  #   return(FALSE)
  # }
  # if(length(list.files(file.path(hdf5projection, platename))) != nrWells) {
  #   warning(sprintf("Plate '%s' seems to be incomplete (hdf5projection incomplete)", platename))
  #   return(FALSE)
  # }
  
  # Check that all log files are present (i.e. this plate is no longer in the queue)
  logfiles = list.files(logdir)
  if(length(logfiles) != (nrWells * 2)) {
    warning(sprintf("Plate '%s' seems to be incomplete (logdir incomplete)", platename))
    return(FALSE)
  }
  
  # Check if there are any non-empty error files
  errfiles = logfiles[grep(pattern = "_err.txt", x = logfiles, fixed = TRUE)]
  infomatrix = file.info(file.path(logdir, errfiles))
  problemwells = rownames(infomatrix)[infomatrix$size != 0]
  
  # Extract well IDs
  problemwells = lapply(problemwells, function(x) {
    strsplit(basename(x), "_")[[1]][1:3]
  })
  
  # Check the hdf5dir / hdf5validation directory for problem wells
  valfiles = sapply(problemwells, function(x) {
    f = validationHdf5Filename(filedir = file.path(hdf5validationdir, x[1]), 
                               platename = x[1], row = x[2], col = x[3])
    read.table(f)[1,1]
  })
  badhdf5dir = problemwells[!valfiles]
  
  # Check the hdf5projection (load it and check how many '0's there are) for 
  # the problem wells
  projfiles = sapply(problemwells, function(x) {
    projectionHdf5Filename(filedir = file.path(hdf5projection, x[1]), 
                           platename = x[1], row = x[2], col = x[3])
  })
  zeroentries = sapply(projfiles, function(x) {
    dat = h5read(x, "images")
    sum(dat == 0)
  })

  # Bad projections will have at least an entire 2048 x 2048 image of zero entries
  badprojections = problemwells[zeroentries >= 2048**2]
  
  badfiles = unique(c(badhdf5dir, badprojections))
  
  if(length(badfiles) == 0) {
    print(sprintf("No bad files on plate '%s'", platename))
    return(FALSE)
  }
  
  shellscript = sapply(badfiles, function(x) {
    hdf5_fn = hdf5Filename(filedir = file.path(hdf5dir, x[1]), 
                           platename = x[1], row = x[2], col = x[3])
    proj_fn = projectionHdf5Filename(
      filedir = file.path(hdf5projection, x[1]), platename = x[1], 
      row = x[2], col = x[3])
    
    val_fn = validationHdf5Filename(
      filedir = file.path(hdf5validationdir, x[1]), platename = x[1], 
      row = x[2], col = x[3])

    entry = c(
      sprintf("rm -f %s", hdf5_fn),
      sprintf("rm -f %s", proj_fn),
      sprintf("rm -f %s", val_fn),
      # sprintf("echo \'export R_LIBS_USER=\"/collab-ag-fischer/Rlibs\"; R --vanilla -e \"%s\" --args %s %s %s %s %s %s\' | %s -e %s -o %s",
      sprintf("echo \'R --vanilla -e \"%s\" --args %s %s %s %s %s %s\' | %s -e %s -o %s", 
              startScript, fctcall, plateIndir, x[1], x[2], x[3], configdir, qsub,
              file.path(configdir, "status", "log", platename, 
                        sprintf("%s_%s_%s_%s_err.txt",x[1],x[2], x[3], fctcall)), 
              file.path(configdir, "status", "log", platename,
                        sprintf("%s_%s_%s_%s_out.txt",x[1],x[2], x[3], fctcall))))
    paste0(entry, collapse = "\n")
  })
  shellscript = paste0(shellscript, collapse = "\n")
  
  write(x = shellscript, file = outfile)
  return(TRUE)
}